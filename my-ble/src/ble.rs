use crate::Event;
use core::mem;
use embassy_sync::blocking_mutex::raw::ThreadModeRawMutex;
use embassy_sync::signal::Signal;
use futures::future::{select, Either};
use futures::pin_mut;

use nrf_softdevice::ble::advertisement_builder::{
    Flag, LegacyAdvertisementBuilder, LegacyAdvertisementPayload, ServiceList, ServiceUuid16,
};
use nrf_softdevice::ble::Connection;

use embassy_executor::Spawner;
use embassy_time::Timer;
use nrf_softdevice::ble::{gatt_server, peripheral};
use nrf_softdevice::{raw, Softdevice};

#[embassy_executor::task]
async fn softdevice_task(sd: &'static Softdevice) -> ! {
    defmt::info!("run softdev");
    sd.run().await
}

#[nrf_softdevice::gatt_service(uuid = "180f")]
struct BatteryService {
    #[characteristic(uuid = "2a19", read, notify)]
    battery_level: u16,
}
#[nrf_softdevice::gatt_service(uuid = "1819")]
struct NavService {
    #[characteristic(uuid = "2c06", read, notify)]
    accel_data_x: u16,
}

#[nrf_softdevice::gatt_service(uuid = "9e7312e0-2354-11eb-9f10-fbc30a62cf38")]
struct FooService {
    #[characteristic(uuid = "9e7312e0-2354-11eb-9f10-fbc30a63cf38", read, write, notify)]
    toto: u8,
}

#[nrf_softdevice::gatt_server]
struct Server {
    bas: BatteryService,
    foo: FooService,
    nav: NavService,
}

pub struct BleTask {
    pub sd: &'static Softdevice,
    server: Server,
    signal: &'static Signal<ThreadModeRawMutex, Event>,
}

impl BleTask {
    pub fn run_softdevice(&self, spawner: &Spawner) {
        defmt::unwrap!(spawner.spawn(softdevice_task(self.sd)));
    }
    pub fn new(signal: &'static Signal<ThreadModeRawMutex, Event>) -> Self {
        let config = nrf_softdevice::Config {
            clock: Some(raw::nrf_clock_lf_cfg_t {
                source: raw::NRF_CLOCK_LF_SRC_RC as u8,
                rc_ctiv: 16,
                rc_temp_ctiv: 2,
                accuracy: raw::NRF_CLOCK_LF_ACCURACY_500_PPM as u8,
            }),
            conn_gap: Some(raw::ble_gap_conn_cfg_t {
                conn_count: 1,
                event_length: 24,
            }),
            conn_gatt: Some(raw::ble_gatt_conn_cfg_t { att_mtu: 256 }),
            gatts_attr_tab_size: Some(raw::ble_gatts_cfg_attr_tab_size_t {
                attr_tab_size: raw::BLE_GATTS_ATTR_TAB_SIZE_DEFAULT,
            }),
            gap_role_count: Some(raw::ble_gap_cfg_role_count_t {
                adv_set_count: raw::BLE_GAP_ADV_SET_COUNT_DEFAULT as u8,
                periph_role_count: raw::BLE_GAP_ROLE_COUNT_PERIPH_DEFAULT as u8,
                central_role_count: 0,
                central_sec_count: 0,
                _bitfield_1: raw::ble_gap_cfg_role_count_t::new_bitfield_1(0),
            }),
            gap_device_name: Some(raw::ble_gap_cfg_device_name_t {
                p_value: b"Sam" as *const u8 as _,
                current_len: 3,
                max_len: 9,
                write_perm: unsafe { mem::zeroed() },
                _bitfield_1: raw::ble_gap_cfg_device_name_t::new_bitfield_1(
                    raw::BLE_GATTS_VLOC_STACK as u8,
                ),
            }),
            ..Default::default()
        };

        let sd = Softdevice::enable(&config);
        let server = defmt::unwrap!(Server::new(sd));

        Self { sd, server, signal }
    }

    pub async fn run(&self) {
        static ADV_DATA: LegacyAdvertisementPayload = LegacyAdvertisementBuilder::new()
            .flags(&[Flag::GeneralDiscovery, Flag::LE_Only])
            .services_16(ServiceList::Complete, &[ServiceUuid16::BATTERY])
            .full_name("Samira")
            .build();

        static SCAN_DATA: LegacyAdvertisementPayload = LegacyAdvertisementBuilder::new()
            .services_128(
                ServiceList::Complete,
                &[0x9e7312e0_2354_11eb_9f10_fbc30a62cf38_u128.to_le_bytes()],
            )
            .build();

        loop {
            // let config = peripheral::Config {
            //     interval: 50,
            //     ..Default::default()
            // };
            let config = peripheral::Config::default();
            let adv = peripheral::ConnectableAdvertisement::ScannableUndirected {
                adv_data: &ADV_DATA,
                scan_data: &SCAN_DATA,
            };
            defmt::info!("Start advertising");
            let conn =
                defmt::unwrap!(peripheral::advertise_connectable(self.sd, adv, &config).await);

            defmt::info!("advertising done! connected");
            self.signal.signal(Event::Buzz);

            // We have a GATT connection. Now we will create two futures:
            //  - An infinite loop gathering data from the ADC and notifying the clients.
            //  - A GATT server listening for events from the connected client.
            //
            // Event enums (ServerEvent's) are generated by nrf_softdevice::gatt_server
            // proc macro when applied to the Server struct above
            let gatt_fut = gatt_server::run(&conn, &self.server, |e| match e {
                ServerEvent::Foo(FooServiceEvent::TotoWrite(val)) => {
                    defmt::info!("wrote foo level: {}", val);
                    if let Err(e) = self.server.foo.toto_notify(&conn, &(val + 1)) {
                        defmt::info!("send notification error: {:?}", e);
                    }
                }
                ServerEvent::Foo(FooServiceEvent::TotoCccdWrite { notifications }) => {
                    defmt::info!("foo notifications: {}", notifications)
                }
                ServerEvent::Bas(e) => match e {
                    BatteryServiceEvent::BatteryLevelCccdWrite { notifications } => {
                        defmt::info!("battery notifications: {}", notifications)
                    }
                },
                ServerEvent::Nav(e) => match e {
                    NavServiceEvent::AccelDataXCccdWrite { notifications } => {
                        defmt::info!("nav notifications: {}", notifications)
                    }
                },
            });
            let adc_fut = self.notify_adc_value(&self.server, &conn);

            pin_mut!(adc_fut);
            pin_mut!(gatt_fut);

            // We are using "select" to wait for either one of the futures to complete.
            // There are some advantages to this approach:
            //  - we only gather data when a client is connected, therefore saving some power.
            //  - when the GATT server finishes operating, our ADC future is also automatically aborted.
            match select(adc_fut, gatt_fut).await {
                Either::Left((_, _)) => {
                    defmt::info!("ADC encountered an error and stopped!")
                }
                Either::Right((e, _)) => {
                    defmt::info!("gatt_server run exited with error: {:?}", e);
                }
            };
        }
    }

    async fn notify_adc_value(
        &self,
        // saadc: &'a mut Saadc<'_, 1>,
        server: &Server,
        connection: &Connection,
    ) {
        let mut adc_raw_value: u16 = 0;
        loop {
            // let mut buf = [0i16; 1];

            // saadc.sample(&mut buf).await;

            // We only sampled one ADC channel.
            // let adc_raw_value: i16 = buf[0];

            // Try and notify the connected client of the new ADC value.
            match server.bas.battery_level_notify(connection, &adc_raw_value) {
                Ok(_) => defmt::info!("Battery adc_raw_value: {=u16}", &adc_raw_value),
                Err(_) => defmt::unwrap!(server.bas.battery_level_set(&adc_raw_value)),
            };
            adc_raw_value = adc_raw_value.overflowing_add(1).0;

            // Sleep for one second.
            Timer::after_millis(1000).await;
        }
    }
}
